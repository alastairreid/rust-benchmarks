#!/usr/bin/env python3

import argparse
import glob
import json
import os
import re
import subprocess
import sys
import toml

from termcolor import colored

# legal responses from this script
# (to match the regtest.py script)
status_timeout   = "SMACK timed out"
status_verified  = None
status_error     = "false verification condition"
status_overflow  = "with overflow"
status_reachable = "statement is reachable"
status_unknown   = "unknown result" # can be any string you like

# This "verifier" was used for debugging the interface to regtest.py but
# is not used anymore.
#
# It cheats at verification by just looking at the filename to decide
# what to report.
# This was surprisingly accurate :-)
def runtest_cheat(test):
  status = status_verified
  if "fail" in test: status = status_error
  if "overflow" in test: status = status_overflow
  return status


# find a function defined in LLVM assembly file
def find_void_function(llfile, path, verbose):
  # if verbose: print(f"    Looking up {path} in {llfile}")
  # apply rustc-style name mangling
  path = [ str(len(n)) + n for n in path ]
  name = "".join(path)

  r = None
  with open(llfile, "r") as f:
    while not r:
      l = f.readline()
      if name not in l: continue
      m = re.match(r'define internal void @_ZN', l)
      if m:
        l = l[m.end():]
        bits = []
        while True:
          m = re.match('(\d+)', l)
          if not m: break
          n = int(m.group(1))
          bits.append(l[m.start(1):m.end(1)+n])
          l = l[m.end(1)+n:]
        if l.startswith("E(") and bits[-1-len(path):-1] == path:
          r = "_ZN" + "".join(bits) +"E"
  # if verbose: print(f"      Found {r}")
  return r


def compile(label, crate, targetdir, runtests, verbose):
  rustflags = [
      '-Clto',
      '-Cembed-bitcode=yes',
      '-Zpanic_abort_tests',
      '--emit=llvm-ir',
      '-Cpanic=abort',
      '-Warithmetic-overflow',
      '--cfg', 'feature="verifier-klee"'
  ]

  flags = []
  if verbose: flags.append("-v")
  if runtests: flags.append("--tests")

  process = subprocess.Popen(['/usr/bin/env', 'cargo', 'build'] + flags,
                             cwd=crate,
                             env = { "RUSTFLAGS": " ".join(rustflags)
                                    , "PATH": os.environ["PATH"] },
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
  if process.returncode != 0:
    print("Couldn't compile")
    print(process.args)
    if verbose:
        print(stdout.decode("utf-8"))
        print(stderr.decode("utf-8"))
    return None

  llfile = glob.glob(f"{targetdir}/debug/deps/{label}*.ll")[0]
  return llfile


# Generate a list of tests in the crate
# by parsing the output of "cargo test -- --list"
def list_tests(crate, verbose):
  process = subprocess.Popen(['/usr/bin/env', 'cargo', 'test', '--', '--list'],
                             #'--exclude-should-panic' ],
                             cwd=crate,
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
  if False and process.returncode != 0:
    print("Couldn't get list of tests")
    print(process.args)
    if verbose:
        print(stdout.decode("utf-8"))
        print(stderr.decode("utf-8"))
    raise Exception("failure")
  else:
    tests = []
    for l in stdout.decode("utf-8").splitlines():
      m = re.match("(\S+):\s+test\s*$", l)
      if m:
        tests.append(m.group(1))
    return tests


def klee(llfile, entry, crate, klee_flags, verbose):
  if verbose: print(f"  Running KLEE on {llfile} entry: {entry}")
  process = subprocess.Popen(['klee',
                              '--entry-point='+entry,
                              '--exit-on-error',
                              # '--posix-runtime',
                              # '--libcxx',
                              '--libc=klee',
                              '--silent-klee-assume']
                             +klee_flags
                             +[llfile],
                             cwd=crate,
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()

  if stdout: print(stdout.decode("utf-8"))
  if verbose > 2:  print(stderr.decode("utf-8")) # useful line for desperate debugging
  for l in stderr.splitlines():
    if l.startswith(b"KLEE: output directory"):
      pass
    elif l.startswith(b"KLEE: Using"):
      pass
    elif l.startswith(b"KLEE: NOTE: Using POSIX model"):
      pass
    elif l.startswith(b"warning: Linking two modules of different data layouts"):
      pass
    elif b"KLEE: WARNING:" in l:
      pass
    elif b"KLEE: WARNING ONCE:" in l:
      pass
    elif b"KLEE: done:" in l:
      pass
    elif l.startswith(b"KLEE: HaltTimer invoked"):
      return status_timeout
    elif l.startswith(b"KLEE: halting execution, dumping remaining states"):
      return status_timeout
    elif l.startswith(b"KLEE: ERROR:") and b"unreachable" in l:
      return status_reachable
    elif l.startswith(b"KLEE: ERROR:") and b"overflow" in l:
      return status_overflow
    elif l.startswith(b"KLEE: ERROR:"):
      print(l)
      if verbose:
        for l in stderr.decode("utf-8").splitlines():
          if l.startswith("KLEE: WARNING"):
            pass
          elif l.startswith("KLEE: Using"):
            pass
          elif l.startswith("KLEE: NOTE"):
            pass
          else:
            print(l)
      return status_error
    elif b"assertion failed" in l:
      print(l)
      return status_error
    elif b"verification failed" in l:
      return status_error
    elif b"with overflow" in l:
      return status_overflow
    elif b"note: run with `RUST_BACKTRACE=1`" in l:
      return status_error
    elif l != b'':
      print(l)
      return status_unknown

  if process.returncode != 0:
    return status_unknown

  return None

def run_proptest(crate):
  process = subprocess.Popen(['/usr/bin/env', 'cargo', 'run'],
                             cwd=crate,
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
  if process.returncode != 0:
    if verbose: print(stderr.decode("utf-8"))
    if verbose: print(stdout.decode("utf-8"))
    for l in stderr.splitlines():
      if b"with overflow" in l:
        return status_overflow
    return status_error
  else:
    return None

def read_metadata(crate):
  process = subprocess.Popen(['/usr/bin/env',
                              'cargo', 'metadata', '--format-version=1'],
                             cwd=crate,
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
  if process.returncode != 0:
    print("Unable to read crate metadata")
    sys.exit(1)
  else:
    return json.loads(stdout)

# This verifier compiles a Rust file and uses KLEE to detect violations
def run_klee(crate, runtests, flags, verbose):
  # Find the target directory and name of package
  metadata = read_metadata(crate)
  targetdir = metadata["target_directory"]
  manifest = toml.load(f"{crate}/Cargo.toml")
  label = manifest["package"]["name"]
  label = label.replace("-", "_")

  # Compile and link the patched file using LTO to generate the entire
  # application in a single LLVM file
  if verbose: print(f"  Compiling {label}")
  llfile = compile(label, crate, targetdir, runtests, verbose)
  if llfile is None:
    if verbose: print(colored(f"  FAILED: Test {label} compilation error", 'red'))
    return status_unknown

  if runtests:
    # get a list of the tests
    tests = list_tests(crate, verbose)
    if not tests:
      print("No tests found")
      return status_unknown
    # then look up their mangled names in the llfile
    tests = [ (t, find_void_function(llfile, t.split('::'), verbose)) for t in tests ]
  else:
    tests = [("main", "main")]

  # For each test function, we run KLEE and sift through the KLEE
  # output to generate an appropriate status string
  for (name, test) in tests:
    if verbose: print(f"  Running KLEE to verify {name}")
    status = klee(llfile, test, crate, flags, verbose)

    if verbose:
      for t in sorted(glob.glob(f"{targetdir}/debug/deps/klee-last/test*.ktest")):
        cmd = []
        cmd.append("/usr/bin/env")
        if runtests:
          cmd.extend(["cargo", "test"])
          cmd.append(name)
        else:
          cmd.extend(["cargo", "run"])
        cmd.append('--')
        if verbose > 1: cmd.append('--nocapture')

        print(f"Rerunning with test {t}")
        process = subprocess.Popen(cmd,
                                   env = {
                                       "KTEST_FILE": t,
                                       "PATH": os.environ["PATH"]
                                   },
                                   cwd=crate,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()
        print(stdout.decode("utf-8"))
        print(stderr.decode("utf-8"))

    if status is not None:
      if verbose: print(colored(f"  FAILED: {name} failed verification", 'red'))
      return status

    # If nothing went wrong, report successful verification
    # (But we are using symbolic execution which may not explore all paths
    # so this really means that no bugs have been found.)
    if verbose: print(colored(f"  PASSED: {name}", 'green'))

  # If every single test passed, return success!
  return status_verified


def main():
  parser = argparse.ArgumentParser(description='Verify a Rust crate')
  parser.add_argument('--backend', metavar='b',
                      choices=['klee', 'proptest'],
                      default="klee",
                      help='select backend')
  parser.add_argument('--verbose', '-v', action='count', default=0)
  parser.add_argument('--tests', action='store_true', default=False,
                      help='run #[test]s instead of main')
  parser.add_argument('crate', help='crate to verify')
  parser.add_argument('klee_flags', nargs="*", help='extra verification flags')
  args = parser.parse_args()

  if args.verbose: print(f"Checking {colored({args.crate}, 'white', attrs=['bold'])}")

  if args.backend == "proptest":
    if verbose: print(f"  Invoking cargo run with proptest backend")
    status = run_proptest(args.crate)
    return status
  else:
    status = run_klee(args.crate, args.tests, args.klee_flags, args.verbose)

  if status: print(status)
  exit(0) # exit status doesn't seem to be important, but use 0


if __name__=="__main__":
  main()
