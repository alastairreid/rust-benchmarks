#!/usr/bin/env python3

import argparse
import glob
import json
import os
import re
import subprocess
import sys
import toml

from termcolor import colored

################################################################
# Return codes from this program
################################################################

status_timeout   = "TIMEOUT"
status_verified  = "VERIFIED"
status_error     = "ERROR"
status_overflow  = "OVERFLOW"
status_reachable = "REACHABLE"
status_unknown   = "UNKNOWN"

################################################################
# Rustc and Cargo utility functions
################################################################

# Read metadata from manifest
def read_metadata(crate, features):
  process = subprocess.Popen(['/usr/bin/env',
                              'cargo', 'metadata', '--format-version=1'] + features,
                             cwd=crate,
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
  if process.returncode != 0:
    print("Unable to read crate metadata")
    print(stderr.decode("utf-8"))
    print(stdout.decode("utf-8"))
    sys.exit(1)
  else:
    return json.loads(stdout)

# Find the target directory
# (This may not be inside the crate if using workspaces)
def get_targetdir(crate, features):
  # Find the target directory and name of package
  metadata = read_metadata(crate, features)
  targetdir = metadata["target_directory"]
  return targetdir

# Find the name of the crate
def get_packagename(crate):
  manifest = toml.load(f"{crate}/Cargo.toml")
  label = manifest["package"]["name"]
  label = label.replace("-", "_")
  return label

# Split mangled rust name into its component parts
def demangle_name(l):
  bits = []
  while True:
    m = re.match('(\d+)', l)
    if not m: break
    n = int(m.group(1))
    bits.append(l[m.start(1):m.end(1)+n])
    l = l[m.end(1)+n:]
  return (bits, l)

# Find a function defined in LLVM bitcode file
#
# This amounts to mangling the function names but is
# more complicated because we don't have the hash value in our hand
def find_void_functions(bcfile, paths, verbose):
  if verbose > 3: print(f"    Looking up {paths} in {bcfile}")
  # apply rustc-style name mangling
  paths = { "".join([ str(len(n)) + n for n in path]): "::".join(path) for path in paths }

  process = subprocess.Popen(['/usr/bin/env', 'llvm-nm', '--defined-only', bcfile],
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
  if process.returncode != 0:
    print("Couldn't run llvm-nm")
    print(process.args)
    if verbose:
        print(stdout.decode("utf-8"))
        print(stderr.decode("utf-8"))
    return None

  rs = []
  for l in stdout.splitlines():
    l = l.split()
    if len(l) == 3 and l[1] in [b't', b'T'] and l[2].startswith(b'_ZN'):
      mangled = l[2].decode('utf-8')
      (name, rest) = demangle_name(mangled[3:])
      key = "".join(name[1:-1])
      if rest == "E" and key in paths:
        t = paths[key]
        f = mangled[0:3] + "".join(name) + rest
        rs.append((t, f))
  if verbose > 3: print(f"      Found {rs}")
  if len(rs) < len(paths):
    raise "Unable to find all tests"
  return rs

# Compile a crate for verification and return a bcfile
# for the entire (linked) crate.
#
# Todo: as more backends are supported, this function is likely
# to need some modification.
def compile(label, crate, runtests, verbose, rustflags, features):
  targetdir = get_targetdir(crate, features)

  flags = features
  if verbose: flags.append("-v")
  if runtests: flags.append("--tests")

  process = subprocess.Popen(['/usr/bin/env', 'cargo', 'build'] + flags,
                             cwd=crate,
                             env = { "RUSTFLAGS": " ".join(rustflags)
                                    , "PATH": os.environ["PATH"] },
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
  if process.returncode != 0:
    print("Couldn't compile")
    print(process.args)
    print(f"RUSTFLAGS = {' '.join(rustflags)}")
    if verbose:
        print(stdout.decode("utf-8"))
        print(stderr.decode("utf-8"))
    return None

  bcfile = glob.glob(f"{targetdir}/debug/deps/{label}*.bc")[0]
  return bcfile


# Generate a list of tests in the crate
# by parsing the output of "cargo test -- --list"
def list_tests(crate, verbose, features):
  process = subprocess.Popen(['/usr/bin/env', 'cargo', 'test']+features+['--', '--list'],
                             #'--exclude-should-panic' ],
                             cwd=crate,
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
  if False and process.returncode != 0:
    print("Couldn't get list of tests")
    print(process.args)
    if verbose:
        print(stdout.decode("utf-8"))
        print(stderr.decode("utf-8"))
    raise Exception("failure")
  else:
    tests = []
    for l in stdout.decode("utf-8").splitlines():
      # print(l)
      m = re.match("(\S+):\s+test\s*$", l)
      if m:
        tests.append(m.group(1))
    return tests


################################################################
# Proptest backend
################################################################

# Invoke proptest to compile and fuzz proptest targets
def run_proptest(crate):
  process = subprocess.Popen(['/usr/bin/env', 'cargo', 'run'] + features,
                             cwd=crate,
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
  if process.returncode != 0:
    if verbose: print(stderr.decode("utf-8"))
    if verbose: print(stdout.decode("utf-8"))
    for l in stderr.splitlines():
      if b"with overflow" in l:
        return status_overflow
    return status_error
  else:
    return status_verified

################################################################
# KLEE backend
################################################################

# Run KLEE on a bitcode file and return a suitable
# status value by grepping KLEE stderr output
def klee_run(bcfile, entry, crate, kleeout, klee_flags, verbose):
  process = subprocess.Popen(['klee',
                              '--entry-point='+entry,
                              '--exit-on-error',
                              # '--posix-runtime',
                              # '--libcxx',
                              '--libc=klee',
                              '--silent-klee-assume',
                              f'--output-dir={kleeout}',
                              '--disable-verify', # workaround https://github.com/klee/klee/issues/937
                              ]
                             +klee_flags
                             +[bcfile],
                             cwd=crate,
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()

  if stdout: print(stdout.decode("utf-8"))
  if verbose > 3:  print(stderr.decode("utf-8")) # useful line for desperate debugging
  for l in stderr.splitlines():
    if l.startswith(b"KLEE: output directory"):
      pass
    elif l.startswith(b"KLEE: Using"):
      pass
    elif l.startswith(b"KLEE: NOTE: Using POSIX model"):
      pass
    elif l.startswith(b"warning: Linking two modules of different data layouts"):
      pass
    elif b"KLEE: WARNING:" in l:
      pass
    elif b"KLEE: WARNING ONCE:" in l:
      pass
    elif b"KLEE: done:" in l:
      pass
    elif l.startswith(b"KLEE: HaltTimer invoked"):
      return status_timeout
    elif l.startswith(b"KLEE: halting execution, dumping remaining states"):
      return status_timeout
    elif l.startswith(b"KLEE: ERROR:") and b"unreachable" in l:
      return status_reachable
    elif l.startswith(b"KLEE: ERROR:") and b"overflow" in l:
      return status_overflow
    elif l.startswith(b"KLEE: ERROR:"):
      print(l)
      if verbose:
        for l in stderr.decode("utf-8").splitlines():
          if l.startswith("KLEE: WARNING"):
            pass
          elif l.startswith("KLEE: Using"):
            pass
          elif l.startswith("KLEE: NOTE"):
            pass
          else:
            print(l)
      return status_error
    elif b"assertion failed" in l:
      print(l)
      return status_error
    elif b"verification failed" in l:
      return status_error
    elif b"with overflow" in l:
      return status_overflow
    elif b"note: run with `RUST_BACKTRACE=1`" in l:
      return status_error
    elif l != b'':
      print(l)
      return status_unknown

  if process.returncode != 0:
    return status_unknown

  # If nothing went wrong, report successful verification
  # (But we are using symbolic execution which may not explore all paths
  # so this really means that no bugs have been found.)
  return status_verified


# Replay a KLEE "ktest" file
def replay_klee(ktest, crate, runtests):
  cmd = []
  cmd.append("/usr/bin/env")
  if runtests:
    cmd.extend(["cargo", "test"])
    cmd.append(name)
  else:
    cmd.extend(["cargo", "run"])
  cmd.append('--')
  cmd.append('--nocapture')

  process = subprocess.Popen(cmd,
                             env = {
                                 "KTEST_FILE": ktest,
                                 "PATH": os.environ["PATH"]
                             },
                             cwd=crate,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
  if process.returncode != 0:
    for l in stderr.splitlines(): print("      " + l.decode("utf-8"))
  for l in stdout.splitlines(): print("      " + l.decode("utf-8"))

# Run KLEE and optionally replay all the paths to display the concrete
# values that will trigger that path.
def klee_verify(bcfile, name, test, crate, runtests, flags, verbose):
  kleeout = os.path.abspath(f"{crate}/kleeout-{name}")
  if os.path.exists(kleeout):
    print(f"Unable to create file {kleeout}")
    return status_unknown
  if verbose > 1: print(f"  Running KLEE to verify {name}")
  if verbose > 2:
    print(f"      file: {bcfile}")
    print(f"      entry: {test}")
    print(f"      results: {kleeout}")
  status = klee_run(bcfile, test, crate, kleeout, flags, verbose)

  if verbose > 1:
    for ktest in sorted(glob.glob(f"{kleeout}/test*.ktest")):
      print(f"    Test input {ktest}")
      replay_klee(ktest, crate, runtests)
  return status


################################################################
# Verifier
#
# This code is (hopefully) independent of which particular
# LLVM-based verifier we are using
################################################################

# Invoke one of the supported verification backends on
# entrypoint 'entry' (with pretty name 'name')
# in bitcodefile 'bcfile'
def verifier_run(bcfile, name, entry, crate, runtests, flags, verbose, backend):
  if backend == "klee":
    status = klee_verify(bcfile, name, entry, crate, runtests, flags, verbose)
    return status
  else:
    if verbose: print(f"Unsupported backend {backend}")
    return status_unknown


# Compile a Rust crate to generate bitcode
# and run one of the LLVM verifier backends on the result.
def verify(label, crate, runtests, verifier_flags, verbose, features, backend):

  # Compile and link the patched file using LTO to generate the entire
  # application in a single LLVM file
  if verbose > 1: print(f"  Compiling {label}")
  rustflags = [
      '-Clto',                 # Generate linked bitcode for entire crate
      '-Cembed-bitcode=yes',
      '--emit=llvm-bc',

      '-Copt-level=1',         # Avoid generating SSE instructions
                               # Any value except 0 seems to work

      # '-Ccodegen-units=1',     # Optimize a bit more?

      '-Zpanic_abort_tests',   # Panic abort is simpler
      '-Cpanic=abort',

      '-Warithmetic-overflow', # Detecting errors is good!
      '-Coverflow-checks=yes',

      '-Cno-vectorize-loops',  # KLEE does not support vector intrinisics
      '-Cno-vectorize-slp',
      '-Ctarget-feature=-sse',
  ]

  bcfile = compile(label, crate, runtests, verbose, rustflags, features)
  if bcfile is None:
    if verbose: print(colored(f"  FAILED: Test {label} compilation error", 'red'))
    return status_unknown

  # If using the --tests flag, generate a list of tests and their mangled names
  if runtests:
    # get a list of the tests
    if verbose > 2: print(f"  Getting list of tests in {label}")
    tests = list_tests(crate, verbose)
    if not tests:
      print("No tests found")
      return status_unknown
    if verbose > 0: print(f"  Checking {' '.join(tests)}")
    # then look up their mangled names in the bcfile
    tests = find_void_functions(bcfile, [ t.split('::') for t in tests ], verbose)
    if verbose > 3: print(f"  Mangled: {tests}")
  else:
    tests = [("main", "main")]

  # For each test function, we run KLEE and sift through the KLEE
  # output to generate an appropriate status string
  for (name, entry) in tests:
    status = verifier_run(bcfile, name, entry, crate, runtests, verifier_flags, verbose, backend)

    if status != status_verified:
      if verbose > 0: print(colored(f"  FAILED: {name} failed verification", 'red'))
      return status

    if verbose: print(colored(f"  PASSED: {name}", 'green'))

  # If every single test passed, return success!
  return status_verified


################################################################
# Main
################################################################

# Invoke a checker (verifier or fuzzer) on a crate
def main():
  parser = argparse.ArgumentParser(description='Verify a Rust crate')
  parser.add_argument('--backend', metavar='b',
                      choices=['klee', 'proptest'],
                      default="klee",
                      help='select backend')
  parser.add_argument('--verbose', '-v', action='count', default=0)
  parser.add_argument('--tests', action='store_true', default=False,
                      help='run #[test]s instead of main')
  parser.add_argument('crate', help='crate to verify')
  parser.add_argument('klee_flags', nargs="*", help='extra verification flags')
  args = parser.parse_args()

  features = []
  if args.backend == "klee": features.extend(['--features', 'verifier-klee'])

  label = get_packagename(args.crate)
  if args.verbose: print(f"Checking {colored(label, 'white', attrs=['bold'])}")

  if args.backend == "proptest":
    if verbose: print(f"  Invoking cargo run with proptest backend")
    status = run_proptest(args.crate)
  else:
    status = verify(label, args.crate, args.tests, args.klee_flags, args.verbose, features, args.backend)

  print(f"VERIFICATION_RESULT: {status}")

  error_code = 0 if status == status_verified else 1
  exit(error_code)


if __name__=="__main__":
  main()
