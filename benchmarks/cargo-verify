#!/usr/bin/env python3

import argparse
import glob
import json
import os
import re
import subprocess
import sys
import toml

from termcolor import colored

status_timeout   = "TIMEOUT"
status_verified  = "VERIFIED"
status_error     = "ERROR"
status_overflow  = "OVERFLOW"
status_reachable = "REACHABLE"
status_unknown   = "UNKNOWN"

def demangle_name(l):
  bits = []
  while True:
    m = re.match('(\d+)', l)
    if not m: break
    n = int(m.group(1))
    bits.append(l[m.start(1):m.end(1)+n])
    l = l[m.end(1)+n:]
  return (bits, l)

# find a function defined in LLVM bitcode file
#
# This amounts to mangling the function names but is
# more complicated because we don't have the hash value in our hand
def find_void_functions(bcfile, paths, verbose):
  if verbose > 3: print(f"    Looking up {paths} in {bcfile}")
  # apply rustc-style name mangling
  paths = { "".join([ str(len(n)) + n for n in path]): "::".join(path) for path in paths }

  process = subprocess.Popen(['/usr/bin/env', 'llvm-nm', '--defined-only', bcfile],
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
  if process.returncode != 0:
    print("Couldn't run llvm-nm")
    print(process.args)
    if verbose:
        print(stdout.decode("utf-8"))
        print(stderr.decode("utf-8"))
    return None

  rs = []
  for l in stdout.splitlines():
    l = l.split()
    if len(l) == 3 and l[1] in [b't', b'T'] and l[2].startswith(b'_ZN'):
      mangled = l[2].decode('utf-8')
      (name, rest) = demangle_name(mangled[3:])
      key = "".join(name[1:-1])
      if rest == "E" and key in paths:
        t = paths[key]
        f = mangled[0:3] + "".join(name) + rest
        rs.append((t, f))
  if verbose > 3: print(f"      Found {rs}")
  if len(rs) < len(paths):
    raise "Unable to find all tests"
  return rs


def compile(label, crate, targetdir, runtests, verbose):
  rustflags = [
      '-Clto',                 # We need bitcode/llvm-as
      '-Cembed-bitcode=yes',
      '--emit=llvm-bc',

      '-Copt-level=1',         # Avoid generating SSE instructions
                               # Any value except 0 seems to work

      '-Zpanic_abort_tests',   # Panic abort is simpler
      '-Cpanic=abort',

      '-Warithmetic-overflow', # Detecting errors is good!

      '-Cno-vectorize-loops',  # KLEE does not support vector intrinisics
      '-Cno-vectorize-slp',
      '-Ctarget-feature=-sse',

      '--cfg', 'feature="verifier-klee"' # Use KLEE version of library
  ]

  flags = []
  if verbose: flags.append("-v")
  if runtests: flags.append("--tests")

  process = subprocess.Popen(['/usr/bin/env', 'cargo', 'build'] + flags,
                             cwd=crate,
                             env = { "RUSTFLAGS": " ".join(rustflags)
                                    , "PATH": os.environ["PATH"] },
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
  if process.returncode != 0:
    print("Couldn't compile")
    print(process.args)
    print(f"RUSTFLAGS = {' '.join(rustflags)}")
    if verbose:
        print(stdout.decode("utf-8"))
        print(stderr.decode("utf-8"))
    return None

  bcfile = glob.glob(f"{targetdir}/debug/deps/{label}*.bc")[0]
  return bcfile


# Generate a list of tests in the crate
# by parsing the output of "cargo test -- --list"
def list_tests(crate, verbose):
  process = subprocess.Popen(['/usr/bin/env', 'cargo', 'test', '--', '--list'],
                             #'--exclude-should-panic' ],
                             cwd=crate,
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
  if False and process.returncode != 0:
    print("Couldn't get list of tests")
    print(process.args)
    if verbose:
        print(stdout.decode("utf-8"))
        print(stderr.decode("utf-8"))
    raise Exception("failure")
  else:
    tests = []
    for l in stdout.decode("utf-8").splitlines():
      # print(l)
      m = re.match("(\S+):\s+test\s*$", l)
      if m:
        tests.append(m.group(1))
    return tests


def klee(bcfile, entry, crate, kleeout, klee_flags, verbose):
  process = subprocess.Popen(['klee',
                              '--entry-point='+entry,
                              '--exit-on-error',
                              # '--posix-runtime',
                              # '--libcxx',
                              '--libc=klee',
                              '--silent-klee-assume',
                              f'--output-dir={kleeout}',
                              '--disable-verify', # workaround https://github.com/klee/klee/issues/937
                              ]
                             +klee_flags
                             +[bcfile],
                             cwd=crate,
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()

  if stdout: print(stdout.decode("utf-8"))
  if verbose > 3:  print(stderr.decode("utf-8")) # useful line for desperate debugging
  for l in stderr.splitlines():
    if l.startswith(b"KLEE: output directory"):
      pass
    elif l.startswith(b"KLEE: Using"):
      pass
    elif l.startswith(b"KLEE: NOTE: Using POSIX model"):
      pass
    elif l.startswith(b"warning: Linking two modules of different data layouts"):
      pass
    elif b"KLEE: WARNING:" in l:
      pass
    elif b"KLEE: WARNING ONCE:" in l:
      pass
    elif b"KLEE: done:" in l:
      pass
    elif l.startswith(b"KLEE: HaltTimer invoked"):
      return status_timeout
    elif l.startswith(b"KLEE: halting execution, dumping remaining states"):
      return status_timeout
    elif l.startswith(b"KLEE: ERROR:") and b"unreachable" in l:
      return status_reachable
    elif l.startswith(b"KLEE: ERROR:") and b"overflow" in l:
      return status_overflow
    elif l.startswith(b"KLEE: ERROR:"):
      print(l)
      if verbose:
        for l in stderr.decode("utf-8").splitlines():
          if l.startswith("KLEE: WARNING"):
            pass
          elif l.startswith("KLEE: Using"):
            pass
          elif l.startswith("KLEE: NOTE"):
            pass
          else:
            print(l)
      return status_error
    elif b"assertion failed" in l:
      print(l)
      return status_error
    elif b"verification failed" in l:
      return status_error
    elif b"with overflow" in l:
      return status_overflow
    elif b"note: run with `RUST_BACKTRACE=1`" in l:
      return status_error
    elif l != b'':
      print(l)
      return status_unknown

  if process.returncode != 0:
    return status_unknown

  return None

def run_proptest(crate):
  process = subprocess.Popen(['/usr/bin/env', 'cargo', 'run'],
                             cwd=crate,
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
  if process.returncode != 0:
    if verbose: print(stderr.decode("utf-8"))
    if verbose: print(stdout.decode("utf-8"))
    for l in stderr.splitlines():
      if b"with overflow" in l:
        return status_overflow
    return status_error
  else:
    return None

def read_metadata(crate):
  process = subprocess.Popen(['/usr/bin/env',
                              'cargo', 'metadata', '--format-version=1'],
                             cwd=crate,
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
  stdout, stderr = process.communicate()
  if process.returncode != 0:
    print("Unable to read crate metadata")
    print(stderr.decode("utf-8"))
    print(stdout.decode("utf-8"))
    sys.exit(1)
  else:
    return json.loads(stdout)

# This verifier compiles a Rust file and uses KLEE to detect violations
def run_klee(crate, runtests, flags, verbose):
  # Find the target directory and name of package
  metadata = read_metadata(crate)
  targetdir = metadata["target_directory"]
  manifest = toml.load(f"{crate}/Cargo.toml")
  label = manifest["package"]["name"]
  label = label.replace("-", "_")

  if verbose: print(f"Checking {colored(label, 'white', attrs=['bold'])}")

  # Compile and link the patched file using LTO to generate the entire
  # application in a single LLVM file
  if verbose > 1: print(f"  Compiling {label}")
  bcfile = compile(label, crate, targetdir, runtests, verbose)
  if bcfile is None:
    if verbose: print(colored(f"  FAILED: Test {label} compilation error", 'red'))
    return status_unknown

  if runtests:
    # get a list of the tests
    if verbose > 2: print(f"  Getting list of tests in {label}")
    tests = list_tests(crate, verbose)
    if not tests:
      print("No tests found")
      return status_unknown
    if verbose > 0: print(f"  Checking {' '.join(tests)}")
    # then look up their mangled names in the bcfile
    tests = find_void_functions(bcfile, [ t.split('::') for t in tests ], verbose)
    if verbose > 3: print(f"  Mangled: {tests}")
  else:
    tests = [("main", "main")]

  # For each test function, we run KLEE and sift through the KLEE
  # output to generate an appropriate status string
  for (name, test) in tests:
    kleeout = os.path.abspath(f"{crate}/kleeout-{name}")
    if os.path.exists(kleeout):
      print(f"Unable to create file {kleeout}")
      return status_unknown
    if verbose > 1: print(f"  Running KLEE to verify {name}")
    if verbose > 2:
      print(f"      file: {bcfile}")
      print(f"      entry: {test}")
      print(f"      results: {kleeout}")
    status = klee(bcfile, test, crate, kleeout, flags, verbose)

    if verbose > 1:
      for t in sorted(glob.glob(f"{kleeout}/test*.ktest")):
        cmd = []
        cmd.append("/usr/bin/env")
        if runtests:
          cmd.extend(["cargo", "test"])
          cmd.append(name)
        else:
          cmd.extend(["cargo", "run"])
        cmd.append('--')
        cmd.append('--nocapture')

        print(f"    Test input {t}")
        process = subprocess.Popen(cmd,
                                   env = {
                                       "KTEST_FILE": t,
                                       "PATH": os.environ["PATH"]
                                   },
                                   cwd=crate,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()
        if process.returncode != 0:
          for l in stderr.splitlines(): print("      " + l.decode("utf-8"))
        for l in stdout.splitlines(): print("      " + l.decode("utf-8"))

    if status is not None:
      if verbose > 0: print(colored(f"  FAILED: {name} failed verification", 'red'))
      return status

    # If nothing went wrong, report successful verification
    # (But we are using symbolic execution which may not explore all paths
    # so this really means that no bugs have been found.)
    if verbose: print(colored(f"  PASSED: {name}", 'green'))

  # If every single test passed, return success!
  return status_verified


def main():
  parser = argparse.ArgumentParser(description='Verify a Rust crate')
  parser.add_argument('--backend', metavar='b',
                      choices=['klee', 'proptest'],
                      default="klee",
                      help='select backend')
  parser.add_argument('--verbose', '-v', action='count', default=0)
  parser.add_argument('--tests', action='store_true', default=False,
                      help='run #[test]s instead of main')
  parser.add_argument('crate', help='crate to verify')
  parser.add_argument('klee_flags', nargs="*", help='extra verification flags')
  args = parser.parse_args()

  if args.backend == "proptest":
    if args.verbose: print(f"Checking {colored({args.crate}, 'white', attrs=['bold'])}")
    if verbose: print(f"  Invoking cargo run with proptest backend")
    status = run_proptest(args.crate)
    return status
  else:
    status = run_klee(args.crate, args.tests, args.klee_flags, args.verbose)

  if status is None: status = status_verified
  print(f"VERIFICATION_RESULT: {status}")

  error_code = 0 if status == status_verified else 1
  exit(error_code)


if __name__=="__main__":
  main()
